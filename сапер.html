<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–∞–ø–µ—Ä</title>
    <style>
        body {
    font-family: Arial, sans-serif;
    text-align: center;
}

h1 {
    margin-top: 20px;
}

#board {
    display: grid;
    grid-template-columns: repeat(20, 30px);
    grid-template-rows: repeat(20, 30px);
    gap: 3px;
    margin-top: 20px;
    justify-content: center;
}

.cell {
    width: 30px;
    height: 30px;
    background-color: lightgray;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    border: 1px solid #888;
    font-size: 14px;
}

.cell.revealed {
    background-color: #ddd;
    cursor: default;
}

.cell.mine {
    background-color: red;
}

.cell.flag {
    background-color: yellow;
}

.cell.safe {
    background-color: gold;
}

#restart {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
    border-radius: 5px;
}

#restart:hover {
    background-color: #45a049;
}

    </style>
</head>
<body>
    <h1>–°–∞–ø–µ—Ä</h1>
    <button id="restart">–†–µ—Å—Ç–∞—Ä—Ç</button>
    <div id="board"></div>
    <script>
        const rows = 20;
const cols = 20;
const mineCount = 60;
let board = [];
let revealedCount = 0;
let gameOver = false;
let firstClick = true;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–æ—Å–∫–∏
function initializeBoard() {
    board = [];
    revealedCount = 0;
    gameOver = false;
    firstClick = true;

    for (let i = 0; i < rows; i++) {
        board[i] = [];
        for (let j = 0; j < cols; j++) {
            board[i][j] = {
                mine: false,
                revealed: false,
                flag: false,
                adjacentMines: 0
            };
        }
    }

    renderBoard();
}

// –†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–∏–Ω, –∏—Å–∫–ª—é—á–∞—è –ø–µ—Ä–≤—É—é –∫–ª–∏–∫–Ω—É—Ç—É—é –∫–ª–µ—Ç–∫—É
function placeMines(excludeRow, excludeCol) {
    let minesPlaced = 0;
    while (minesPlaced < mineCount) {
        const r = Math.floor(Math.random() * rows);
        const c = Math.floor(Math.random() * cols);
        
        // –ò—Å–∫–ª—é—á–∞–µ–º –ø–µ—Ä–≤—É—é –∫–ª–µ—Ç–∫—É –∏ –µ—ë —Å–æ—Å–µ–¥–µ–π
        if (!board[r][c].mine && (Math.abs(r - excludeRow) > 1 || Math.abs(c - excludeCol) > 1)) {
            board[r][c].mine = true;
            minesPlaced++;
        }
    }

    calculateAdjacentMines();
}

// –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–∏–Ω –≤–æ–∫—Ä—É–≥ –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–∏
function calculateAdjacentMines() {
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (board[i][j].mine) continue;
            let adjacentMines = 0;
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    const ni = i + x;
                    const nj = j + y;
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && board[ni][nj].mine) {
                        adjacentMines++;
                    }
                }
            }
            board[i][j].adjacentMines = adjacentMines;
        }
    }
}

// –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–æ—Å–∫–∏
function renderBoard() {
    const boardElement = document.getElementById("board");
    boardElement.innerHTML = "";
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            if (board[i][j].revealed) {
                if (board[i][j].mine) {
                    cell.classList.add("mine");
                    cell.textContent = "üí£";
                } else {
                    if (board[i][j].adjacentMines > 0) {
                        cell.textContent = board[i][j].adjacentMines;
                    } else {
                        cell.classList.add("safe");
                    }
                }
            }
            if (board[i][j].flag) {
                cell.classList.add("flag");
                cell.textContent = "üö©";
            }

            cell.addEventListener("click", () => cellClick(i, j));
            cell.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                cellFlag(i, j);
            });

            boardElement.appendChild(cell);
        }
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –Ω–∞ –∫–ª–µ—Ç–∫—É
function cellClick(row, col) {
    if (gameOver || board[row][col].flag) return;

    // –ï—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤—ã–π –∫–ª–∏–∫, —Ä–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –º–∏–Ω—ã
    if (firstClick) {
        placeMines(row, col);
        firstClick = false;
    }

    // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–æ–π —á–∏—Å–ª–æ–≤–æ–π –∫–ª–µ—Ç–∫–µ - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–ª–∞–∂–∫–∏
    if (board[row][col].revealed && board[row][col].adjacentMines > 0) {
        checkAndRevealSurroundings(row, col);
        return;
    }

    revealCell(row, col);
    renderBoard();
}

// –û—Ç–∫—Ä—ã–≤–∞–µ—Ç –∫–ª–µ—Ç–∫—É –∏ —Å–æ—Å–µ–¥–Ω–∏–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∫–ª–µ—Ç–∫–∏
function revealCell(row, col) {
    if (board[row][col].revealed || board[row][col].flag) return;

    board[row][col].revealed = true;
    revealedCount++;

    if (board[row][col].mine) {
        gameOver = true;
        alert("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í—ã –ø–æ–¥–æ—Ä–≤–∞–ª–∏—Å—å –Ω–∞ –º–∏–Ω–µ.");
        revealMines();
    } else if (board[row][col].adjacentMines === 0) {
        revealAdjacentCells(row, col);
    }
}

// –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –ª–∏ —Ñ–ª–∞–∂–∫–∏ —á–∏—Å–ª—É –≤ –∫–ª–µ—Ç–∫–µ
function checkAndRevealSurroundings(row, col) {
    let flagCount = 0;
    let closedCells = [];

    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–ª–∞–≥–∏ –∏ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –∑–∞–∫—Ä—ã—Ç—ã–µ –∫–ª–µ—Ç–∫–∏ –≤–æ–∫—Ä—É–≥
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            const ni = row + x;
            const nj = col + y;
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {
                if (board[ni][nj].flag) flagCount++;
                if (!board[ni][nj].revealed && !board[ni][nj].flag) closedCells.push([ni, nj]);
            }
        }
    }

    // –ï—Å–ª–∏ —Ñ–ª–∞–≥–æ–≤ —Ä–æ–≤–Ω–æ —Å—Ç–æ–ª—å–∫–æ, —Å–∫–æ–ª—å–∫–æ —É–∫–∞–∑–∞–Ω–æ –≤ –∫–ª–µ—Ç–∫–µ - –æ—Ç–∫—Ä—ã–≤–∞–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ
    if (flagCount === board[row][col].adjacentMines) {
        closedCells.forEach(([r, c]) => revealCell(r, c));
        renderBoard();
    }
}

// –û—Ç–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –∫–ª–µ—Ç–æ–∫ —Å –Ω—É–ª—è–º–∏
function revealAdjacentCells(row, col) {
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            const ni = row + x;
            const nj = col + y;
            if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && !board[ni][nj].revealed) {
                revealCell(ni, nj);
            }
        }
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–∞–≤–æ–≥–æ –∫–ª–∏–∫–∞ (—Ñ–ª–∞–∂–æ–∫)
function cellFlag(row, col) {
    if (gameOver || board[row][col].revealed) return;

    board[row][col].flag = !board[row][col].flag;
    renderBoard();
}

// –û—Ç–∫—Ä—ã—Ç–∏–µ –≤—Å–µ—Ö –º–∏–Ω –ø—Ä–∏ –ø–æ—Ä–∞–∂–µ–Ω–∏–∏
function revealMines() {
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (board[i][j].mine) {
                board[i][j].revealed = true;
            }
        }
    }
    renderBoard();
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã
function restartGame() {
    initializeBoard();
}

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ —Ä–µ—Å—Ç–∞—Ä—Ç–∞
document.getElementById("restart").addEventListener("click", restartGame);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
initializeBoard();

    </script>
</body>
</html>
